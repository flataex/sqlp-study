## 2장. 데이터 모델과 SQL
### :pencil2: 1. 정규화

`관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스`를 의미

#### 1. 제 1정규형 
> 모든 속성은 반드기 하나의 값을 가진다.

|AS-IS|TO-BE|
|:---:|:---:|
|![스크린샷 2023-04-17 오전 8 01 15](https://user-images.githubusercontent.com/130142107/232347871-a45da15b-a448-4fc8-a654-a9e2f974b7dd.png)|![스크린샷 2023-04-17 오전 8 01 35](https://user-images.githubusercontent.com/130142107/232347879-cbba2250-565f-4847-b050-6f6ae570a7c3.png)|

* 제 1정규형은 다중 값 외 중복 데이터를 의미할 수 도 있음 
  * 해당 경우는 관련 entity를 추가한다.


#### 2. 제 2정규형 
> 엔터티의 `일반 속성`은 `주식별자 전체에 종속적`이어야한다. <br/>

[이미지 1-1. 제2정규화를 위배하는 Entity]
![스크린샷 2023-04-17 오전 8 11 22](https://user-images.githubusercontent.com/130142107/232348536-93d93c95-3f4b-476f-aa3b-81e8f6df6a07.png) <br/>

* 함수적 종속성 

  ![스크린샷 2023-04-17 오전 8 09 42](https://user-images.githubusercontent.com/130142107/232348253-c79cd34f-037f-4fcb-8b1b-2670847d8415.png)
  
  * 데이터들이 어떤 `기준 값`에 의해 종속되는 현상을 의미 
  * `기준 값` == 결정자
  * `종속되는 값` == 종속자

 * 부분 종속 
  
  * 식별자 전체가 아닌 일부에만 종속적인 경우  
  * `이미지 1-1`의 주문 상세 Entity의 상품명을 의미 
  
##### 2.1 제 2 정규화 위배의 문제점 

* 부분 종속된 값이 변경될 경우, Entity의 중복된 모든 값을 변경하여야 한다. 
  > `즉, 주문 상세 엔터티 내 상품명 변경 -> 중복되는 상품명 모두 변경이 필요`

* 변경된 값은 반영하더라도, 특정 시점에 변경되지 않은 중복된 값이 존재
  
  > 따라서, `트랜잭션은 일관성이 깨지는 데이터를 조회`

[이미지 1-2. 제 2정규화]

![스크린샷 2023-04-17 오전 8 23 32](https://user-images.githubusercontent.com/130142107/232349076-a428c102-e657-454b-8dd6-614e3f671c8f.png)

  :white_check_mark: 관련 엔터티를 추가하여 부분 종속을 제거한다.

#### 3. 제 3정규형 
> 엔터티의 일반속성 간에는 서로 종속적 :x: `(이행적 종속을 배제한다.)` <br/>
> 즉, 이행적 종속을 위배 == 제 3정규형 위배 <br/>
> 제 2 정규형을 기본적으로 만족하되, 테이블 내의 모든 속성이 기본키에만 의존 (다른 후보키에 의존 X)


|2nf|3nf|
|:---:|:---:|
|![스크린샷 2023-04-17 오전 8 32 45](https://user-images.githubusercontent.com/130142107/232349547-c06c4128-117e-44d0-a7a4-a883ed26a2eb.png)|![스크린샷 2023-04-17 오전 8 35 10](https://user-images.githubusercontent.com/130142107/232349572-fad21689-1e1d-47d8-a384-446294e6e425.png)|

#### 4. 반 정규화와 성능 
> 정규화의 반대를 의미 (== `역정규화`) <br/>
> * 즉, 정규화에서 데이터의 중복을 최소화하였다면,
> * 역정규화는 성능을 위해 데이터 중복을 허용한다. 
>   * ex) tbl_kyc_info...?  
---

### :pencil2: 2. 관계와 조인의 이해 
> 관계는 부모의 식별자를 자식에게 상속시키는 행위 <br/>
> `식별관계` : 부모의 식별자를 자식의 식별자에 포함  <br/>
> `비식별관계` : 부모의 식별자를 자식의 일반 속성으로만 사용 <br/>
> `조인` :식별자를 상속하고 상속된 속성을 맵핑 키로 활용하여 데이터를 결합

 ![스크린샷 2023-04-18 오후 11 35 58](https://user-images.githubusercontent.com/130142107/232811317-5dede1ff-a8ce-4a76-9b8e-82a66b89060c.png)

 ```SQL 
 SELECT B.고객명 
 FROM 주문 A 
 INNER JOIN 고객 B
  ON A.고객번호 = B.고객번호 AND A.주문번호 = '1100001'
 
 ```
 
  #### 2.1. 계층형 데이터 모델 
  > 계층구조를 가진 데이터를 지칭
  
  * `셀프조인` : 자기 자신을 조인 
   
   * ex) 
    ![스크린샷 2023-04-18 오후 11 47 28](https://user-images.githubusercontent.com/130142107/232814930-3732df71-73be-4fb9-ad35-95cdc7729b5e.png)
    
     ```SQL
     SELECT  B.ENAME AS '사원명'
     FROM EMP A, EMP B
     WHERE A.ENAME = 'SMITH'
      AND A.MGR = B.EMPNO;
     ```
    
     > 해당 테이블의 구조에서 상속된 식별자의 속성은 MGR. 해당 속성을 매핑 키로 사용하여 조인을 수행한다. 
   
  #### 2.2. 상호배타적(Exclusive-OR) 관계 
  > 2개 이상의 부모 엔터티와 관계를 맺고, 그 관계가 상호 배타적일때의 관계를 의미함
  
   [이미지 1-3. 상호배타적 관계의 예시]
   ![스크린샷 2023-04-19 오전 12 01 41](https://user-images.githubusercontent.com/130142107/232818940-bc231d14-333d-421c-b98c-cd3794946d72.png)

  * `이미지 1-3`의 경우 처럼 개인, 법인 엔터티가 주문 엔터티와의 관계를 설정하고 있음
  * IE 표기법은 상호 배타적 관계 표기를 지원하지 않음 
  * `개인/법인 번호는 FK로서, 주문 엔터티에 개인/법인 중 하나만 상속될 수 있음을 의미.`
  
  [이미지 1-4. 주문 테이블]
  ![스크린샷 2023-04-19 오전 12 08 40](https://user-images.githubusercontent.com/130142107/232820976-84e58139-0bf7-401d-a453-b7a80e819a1e.png)

  :exclamation: 상호 배타적 관계의 경우, 우선 순위를 설정이 필요. <br/> 
  :exclamation: **상속을 구별하는 구분자는 NULL을 허용 X** : `이미지 1-4] 주문 테이블` 에서는 구분자는 `고객구분코드`가 된다. <br/> 
  :exclamation: 식별자가 상속된 속성은 중복이 발생되면 안된다! :heavy_check_mark: :heavy_check_mark:    
  
 :white_check_mark: Tip)
 > :link: [COALESCE](https://wakestand.tistory.com/485) 메서드 
 > 입력한 파라미터 중 NULL이 아닌 값 중 선입선출 <br/> 
 > 메서드로 입력한 파라미터가 모두 NULL일 경우에만 NULL을 반환.
  
 ```SQL 
 SELECT COALESCE(B.개인고객명, C.법인명) AS 고객명
 FROM 주문 A
 LEFT JOIN 개인고객 B
  ON A.개인/법인번호 = B.개인번호 
 LEFT JOIN 법인고객 C
  ON A.개인/법인번호 = C.법인번호
 WHERE A.주문번호 = '1100001';
 ```
 
---
### :pencil2: 3. 모델이 표현하는 트랜잭션의 이해
> `트랜잭션` : 데이터베이스의 논리적인 연산 단위 <br/>
> **주문과 주문상세와 같이 동시 발생되는 경우의 데이터는 `하나의 트랜잭션으로 묶어서 관리`한다.** <br/>
> 하나의 트랜잭션을 묶는다는 의미 : 커밋의 단위를 하나로 가져갓!

:trollface: 흠..결재 기능 구현 시, 나는 해당 동시 발생이 요구되는 작업을 하나의 트랜잭션으로 관리하였을까..? :trollface: 트랜잭션 별 Level를 부여하여 처리한다면..? 어떨까?..

---
### :pencil2: 4. Null 속성의 이해

#### 1. NULL 값의 연산은 언제나 NULL이다.
> NULL 체크 및 값 치환 메서드 : NVL == IFNULL == ISNULL <br/>
> NVL(컬럼, '지정값') : 컬럼에 지정된 값이 NULL일 경우 지정된 값으로 치환되어 출력됨.

```SQL
SELECT NVL(code, '넌 NULL이다.') FROM EMP
```
#### 2. 집계함수는 NULL 값을 제외하고 처리한다.  

---
### :pencil2: 5. 본질식별자 vs 인조식별자 
> `본질 식별자` : 업무에 의해 만들어진 식별자  <br/>
> `인조 식별자` : 업무적으로 만들어지지는 않았지만, 필요에 의해 인위적으로 생성된 식별자 
ex) auto_increment  <br/>
> :link: [NEXTVAL](https://change-words.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4ORACLE-%EC%8B%9C%ED%80%80%EC%8A%A4SEQUENCE-NEXTVAL-CURRVAL-%EC%B4%88%EA%B8%B0%ED%99%94) 란? <br/>
> 현재 시퀀스의 다음 값을 불러오는 메서드 <br/>
> `(mysql에서는 시퀀스 기능이 없어, 별도로 존재하지 않아서 구현해줘야함..)` 

 




