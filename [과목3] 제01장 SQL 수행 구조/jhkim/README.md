# 제 1절 데이터베이스 아키텍처

## 1. 데이터베이스 구조

### Oracle 구조

오라클 데이터베이스는 크게 `데이터베이스`와 `인스턴스`로 나눌 수 있다.

- **데이터베이스(Database)** 는 디스크에 저장된 실제 데이터 파일들을 의미합니다. 이러한 파일은 주로 세 가지 유형이 있습니다:
    1. **데이터 파일(Datafiles)**: 데이터 파일은 데이터베이스의 실제 데이터를 저장합니다. 이는 테이블, 인덱스, 등의 데이터베이스 객체를 포함합니다. 각 데이터 파일은 특정 테이블스페이스에 속하며, 테이블스페이스는 일련의 데이터 파일을 그룹화하는 논리적인 저장 단위입니다.
    2. **리두 로그 파일(Redo Log Files)**: 리두 로그 파일은 데이터베이스의 모든 변경 사항을 기록하는 로그입니다. 이는 데이터베이스 복구 시 사용되며, 데이터베이스의 모든 트랜잭션과 함께 유지되어야 합니다.
    3. **제어 파일(Control Files)**: 제어 파일은 데이터베이스의 중요한 메타데이터를 저장합니다. 이에는 데이터베이스 이름, 데이터 파일 및 리두 로그 파일의 위치, 데이터베이스 생성 시간 등의 정보가 포함됩니다.
    
- **인스턴스(Instance)** 는 오라클 데이터베이스 시스템에서 메모리와 프로세스를 관리하는 역할을 합니다. 인스턴스는 두 가지 주요 구성 요소로 구성되어 있습니다:
    1. **시스템 전역 영역(System Global Area, SGA)**: SGA는 공유 메모리 영역으로, 모든 데이터베이스 사용자가 공유합니다. SGA는 다음의 세부 구성 요소로 구성되어 있습니다:
        - **데이터베이스 버퍼 캐시**: 데이터베이스 블록을 캐싱하는 공간입니다. 이를 통해 디스크 I/O를 최소화하고 성능을 향상시킵니다.
        - **공유 풀**: 파싱된 SQL 문장, 데이터 딕셔너리 정보 등을 캐싱하는 공간입니다.
        - **리두 로그 버퍼**: 변경된 데이터를 임시로 저장하는 공간으로, 데이터베이스의 트랜잭션을 기록합니다.
    2. **백그라운드 프로세스(Background Processes)**: 이들은 데이터베이스 작업을 지원하는 데 필요한 다양한 작업을 수행합니다. 예를 들어, DBWn은 메모리에서 디스크로 데이터를 쓰는 작업을 수행하고, LGWR은 리두 로그 버퍼의 내용을 리두 로그 파일로이동시키는 작업을 수행합니다. 다른 중요한 백그라운드 프로세스로는 SMON(System Monitor), PMON(Process Monitor), CKPT(Checkpoint), ARCH(Archiver) 등이 있습니다. 이들은 각각 시스템 복구, 프로세스 복구, 체크포인트 정보 관리, 리두 로그의 아카이빙 등을 담당합니다.

### 작동순서

1. `사용자가 SQL 쿼리를 실행` 
2. `오라클 인스턴스는 해당 쿼리를 파싱하고 최적화`
3. `파싱된 SQL 문장은 공유 풀에 저장되어 재사용될 수 있음` 
4. `쿼리가 실행`
    1. `필요한 데이터는 데이터베이스 버퍼 캐시에서 찾아짐` 
    2. `만약 데이터가 캐시에 없으면, 이 데이터는 디스크의 데이터 파일에서 읽어와서 버퍼 캐시에 저장`
5. `데이터베이스에서 데이터가 변경`
    1. 이 변경 사항은 먼저 리두 로그 버퍼에 기록. 
    2. LGWR 프로세스는 리두 로그 버퍼의 내용을 디스크의 리두 로그 파일로 주기적으로 이동시킨다. 만약 시스템에 문제가 발생하여 데이터가 손상되더라도 리두 로그를 사용하여 데이터를 복구할 수 있다.

### SQL Server 구조

**1. 메모리 풀**
SQL Server의 메모리 관리 시스템은 크게 `버퍼 풀`과 `프로시저 캐시`로 구성

- **버퍼 풀(Buffer Pool)**: 데이터베이스 페이지를 캐시하는 메모리 영역입니다. 데이터를 읽거나 쓸 때, SQL Server는 먼저 버퍼 풀에서 해당 페이지를 찾습니다. 페이지가 버퍼 풀에 없는 경우에만 디스크에서 읽어옵니다. 이는 디스크 I/O를 줄이고 성능을 향상시킵니다.
- **프로시저 캐시(Procedure Cache)**: 실행 계획을 저장하는 메모리 영역입니다. SQL Server는 쿼리를 실행하기 전에 프로시저 캐시에서 실행 계획을 찾습니다. 이미 존재하는 실행 계획을 재사용하면 쿼리 최적화 과정을 건너뛸 수 있으므로 성능을 향상시킵니다.

**2. 백그라운드 프로세스**
SQL Server는 여러 백그라운드 프로세스를 통해 여러 작업을 동시에 처리한다.

- **체크포인트(Checkpoint)**: 체크포인트 프로세스는 버퍼 풀에 있는 수정된 페이지를 디스크에 기록합니다. 이는 데이터베이스 복구 시간을 줄이고 데이터 무결성을 보장합니다.
- **로그 라이터(Log Writer)**: 로그 라이터 프로세스는 트랜잭션 로그 버퍼의 내용을 디스크에 기록합니다.

**3. 데이터 파일과 트랜잭션 로그**:
SQL Server 데이터베이스는 하나 이상의 데이터 파일과 하나 이상의 로그 파일로 구성

- **데이터 파일(Data Files)**: 실제 데이터와 인덱스를 저장합니다. 데이터 파일에는 두 가지 유형이 있습니다: 주 데이터 파일과 보조 데이터 파일. 주 데이터 파일은 확장자가 `.mdf`이며, 보조 데이터 파일은 `.ndf`
- **로그 파일(Transaction Log Files)**: 모든 트랜잭션에 대한 정보를 기록합니다. 트랜잭션 로그는 데이터 무결성을 보장하고, 시스템 장애가 발생했을 때 데이터를 복구하는 데 사용.

## 프로세스

### 서버 프로세스

1. **전용 서버 프로세스 방식 (Dedicated Server Process)**

전용 서버 프로세스 방식에서는 클라이언트 프로세스마다 서버 프로세스가 하나씩 할당됩니다. 이 방식은 클라이언트와 서버 간에 1:1 관계를 형성합니다. 클라이언트가 연결되면, 전용 서버 프로세스가 생성되며, 해당 클라이언트의 모든 요청을 처리합니다.

이 방식의 장점은 각 클라이언트가 전용 서버 프로세스를 가지고 있으므로, 특정 클라이언트의 작업이 다른 클라이언트의 성능에 영향을 주지 않는다는 점입니다. 하지만 많은 클라이언트가 동시에 연결되는 환경에서는 서버 프로세스의 수가 급증하므로, 메모리 사용량과 시스템 오버헤드가 증가할 수 있습니다.

1. **공유 서버 프로세스 방식 (Shared Server Process)**

공유 서버 프로세스 방식에서는 여러 클라이언트 프로세스가 서버 프로세스를 공유합니다. 이 방식은 클라이언트와 서버 간에 M:N 관계를 형성합니다. 클라이언트가 요청을 보내면, 요청은 공유 서버 프로세스 풀에 있는 사용 가능한 프로세스 중 하나에 의해 처리됩니다.

이 방식의 장점은 서버 프로세스의 수를 줄이므로, 메모리 사용량과 시스템 오버헤드를 감소시킨다는 점입니다. 이 방식은 많은 수의 클라이언트가 동시에 연결되는 환경에 적합합니다. 하지만, 공유 서버 프로세스가 모든 클라이언트의 요청을 공평하게 처리하도록 스케줄링이 필요하며, 일부 특정 클라이언트의 요청이 다른 클라이언트의 성능에 영향을 줄 수 있습니다.

### 백그라운드 프로세스

| Oracle | SQL Server |
| --- | --- |
| System Monitor(SMON) | Database cleanup/shrinking thread |
| Process Monitor(PMON) | Open Data Services(OPS) |
| Database Writers(DBWn) | Lazywriter thread |
| Log Writer(LGWR) | Log writer thread |
| Archiver(ARCn) | N/A |
| CheckPoint(CKPT) | Database Checkpoint thread |
| Recoverer(RECO) | Distributed Transaction Coordinator(DTC) |

## 데이터 저장 구조

### 데이터 파일

1. 블록(페이지)
2. 익스텐트
3. 세그먼트
4. 테이블스페이스

### 로그파일

- **Oracle - Redo Log**
- **SQL Server - Transaction Log**

`Random I/O 과 Append 방식???`

**Random I/O 방식**

Random I/O 방식은 데이터베이스가 디스크의 여러 위치에 존재하는 블록을 임의로 읽고 쓰는 방식. 이 방식은 일반적으로 인덱스 또는 테이블 스캔 등에서 사용. 데이터베이스는 원하는 데이터를 찾기 위해 디스크의 여러 위치를 접근해야 하므로 I/O 작업이 분산되어 발생하며, 이로 인해 I/O 부하가 상당히 높아질 수 있다.

**Append 방식**

Append 방식은 데이터베이스가 디스크에 순차적으로 데이터를 추가하는 방식. 이 방식은 일반적으로 로그 파일이나 일부 데이터베이스 시스템에서의 테이블 저장 등에 사용된다. Append 방식은 디스크의 특정 위치에 연속적으로 데이터를 쓰므로 I/O 작업이 순차적으로 일어나고, 이로 인해 I/O 부하를 상대적으로 줄일 수 있다.

**각 방식은 사용하는 목적과 환경에 따라 선택하며, 특정 상황에 더 적합한 방식을 사용해야 한다. 예를 들어, 로그 파일을 쓸 때는 Append 방식이, 특정 데이터를 찾을 때는 Random I/O 방식이 더 효율적일 수 있다.**

## 메모리 구조

- 시스템 공유 메모리 영역
    - **Oracle - SGA**
    - **SQL Server - Memory Pool**
- 프로세스 전용 메모리 영역

1. **DB 버퍼 캐시**
- 버퍼 블록의 상태
    - Free 버퍼
    - Dirty 버퍼
    - Pinned 버퍼
- **LRU 알고리즘**
1. **공유 풀**
    1. 딕셔너리 캐시
    2. 라이브러리 캐시
2. **로그 버퍼**
3. **PGA**
    1. User Global Area(UGA)
    2. Call Global Area
    3. Sort Area

# 제 2절 SQL 처리 과정

## SQL 처리 과정

| 서브 엔진 | 역할 |
| --- | --- |
| Parser | SQL 문장을 분석하고 구문을 확인합니다. 또한, 데이터베이스에 존재하는 테이블과 컬럼을 참조하고, 사용자가 적절한 권한을 가지고 있는지 확인합니다. |
| Query Transformer | SQL 문장을 최적화 할 수 있는 다른 형태로 변환합니다. 이 과정에서 인라인 뷰, 복잡한 연산자 등을 단순화하거나, 가능한 경우 조건을 추가하거나 제거합니다. |
| Estimator | 변환된 쿼리의 각 가능한 실행 계획에 대한 비용을 추정합니다. 데이터베이스 통계를 사용하여 I/O, CPU 사용량, 통신 비용 등을 고려하여 계산합니다. |
| Plan Generator | 추정된 비용을 기반으로 최적의 실행 계획을 선택합니다. 선택된 계획은 SQL 엔진에 의해 실행될 준비가 되면, 해당 계획을 캐시에 저장합니다. |
| Row Source Generator | 선택된 실행 계획을 이해하고 실행할 수 있는 저수준의 단계로 변환합니다. 이 단계는 트리 구조로 되어 있으며, 각 노드는 테이블 스캔, 조인, 정렬 등의 작업을 나타냅니다. |
| SQL Engine | 최종적으로 준비된 실행 계획을 바탕으로 SQL 문장을 실행합니다. 필요한 데이터를 가져오고, 적절한 연산을 수행하고, 결과를 반환합니다. |

## SQL 옵티마이저

- 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진.

## 옵티마이저 힌트

- SQL 쿼리문 작성 시 데이터베이스 관리 시스템에게 특정 쿼리를 어떤 방식으로 처리해야 하는지를 제안하는 방법

```sql
SELECT /*+ INDEX(e emp_emp_id_pk) */ emp_id, last_name
FROM employees e
WHERE emp_id = 17;
```

> 신기하게도 주석부분을 데이터베이스에서 읽고 작동함.
> 

# 제 3절 데이터베이스 I/O 메커니즘

## 블록 단위 I/O

1. SQL 성능을 좌우하는 가장 중요한 성능지표는 블록 개수!
2. 하나의 레코드를 읽더라도 레코드가 속한 블록 전체를 읽는다.
3. 버퍼캐시와 데이터 파일 I/O 모두에 적용됨.

## 메모리 I/O vs 디스크 I/O

1. I/O 효율화 튜닝의 중요성
    1. 디스크 I/O를 최소화 하고 버퍼 캐시 효율을 높이는것이 목표.
2. 버퍼 캐시 히트율
    
    `BCHR = (버퍼캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) x 100`
    

## Sequential I/O vs Random I/O

- **Sequential I/O**

데이터가 디스크 상의 연속적인 위치에서 차례로 읽거나 쓰는 방식. 이 방식은 디스크 헤드의 물리적인 이동을 최소화하므로, Random I/O에 비해 훨씬 효율적이며 빠른 성능을 제공한다.

- **Random I/O**

이 방식은 데이터가 디스크의 여러 위치에 흩어져 있을 때 발생한다.즉, 데이터를 읽거나 쓰기 위해 디스크 헤드가 물리적으로 디스크 상의 여러 위치를 빠르게 이동해야 하는 방식이다. 이런 방식은 디스크 헤드의 빈번한 위치 이동으로 인해 오버헤드가 발생하며, 이로 인해 성능이 저하될 수 있다.

`**I/O 튜닝의 핵심 원리 두가지!!!**`

1. **시퀀셜 액세스에 의한 선택비중 높이기**
2. **랜덤 액세스 줄이기**

## Single Block I/O vs MultiBlock I/O

- **Single Block I/O**

한 번의 I/O 작업으로 하나의 블록(또는 페이지)만 읽거나 쓰는 방식. 이 방식은 주로 인덱스를 통한 데이터 검색이나 특정 행의 조회 등에 사용된다.

- **MultiBlock I/O**

한 번의 I/O 작업으로 여러 블록을 동시에 읽거나 쓰는 방식. 이 방식은 주로 테이블 전체를 스캔하거나 대용량 데이터를 읽거나 쓸 때 사용된다. MultiBlock I/O는 Single Block I/O보다 데이터 처리 효율이 높은 편이다.왜냐하면 디스크에서 한 번에 많은 양의 데이터를 읽을 수 있으므로, 디스크 헤드의 물리적인 이동을 줄이고, 따라서 I/O 성능을 향상시킬 수 있기 때문입니다.

## I/O 효율화 원리

1. **필요한 최소 블록만 읽도록 SQL 작성**
2. **최적의 옵티마이지 팩터 제공**
3. **필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도**